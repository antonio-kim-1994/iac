# istio gateway 설정
gateway:
  enabled: true
  name: argocd-gateway

argoApplication:
  ecrUrl: ""
  chart: "helm/service-common"
  manifestGitUrl: "https://github.com/sample-org/eks-helm-dev.git"
  applications: []

# argoCD REPO 설정
applicationRepository:
  secretStoreName: dev-store
  ecrAuth:
    enabled: true
    name: argo-ecr-auth
    region: ap-northeast-2
  helm:
    enabled: true
    externalSecretName: argo-ecr
    secretName: argo-ecr-oci
    refreshInterval: 5m
    secretProperties:
      - secretKey: url
        remoteRef:
          key: /secret/devops_dev
          property: ECR_REPO_URL
  git:
    enabled: true
    externalSecretName: argo-github-external-secret
    secretName: argo-github
    secretProperties:
      - secretKey: username
        remoteRef:
          key: /secret/devops_dev
          property: GITHUB_USER_NAME
      - secretKey: password
        remoteRef:
          key: /secret/devops_dev
          property: GITHUB_PASSWORD
      - secretKey: type
        remoteRef:
          key: /secret/devops_dev
          property: HELM_VALUE_REPO_TYPE
      - secretKey: url
        remoteRef:
          key: /secret/devops_dev
          property: HELM_VALUE_GITHUP_URL

global:
  domain: dev-argo.service.com
  runtimeClassName: ""
  additionalLabels: {}
  revisionHistoryLimit: 3
  image:
    repository: quay.io/argoproj/argocd
    tag: ""
    imagePullPolicy: IfNotPresent

  imagePullSecrets: []

  logging:
    format: text
    level: info

  deploymentAnnotations: {}
  podAnnotations: {}
  podLabels: {}
  addPrometheusAnnotations: false
  securityContext: {}
  #  runAsUser: 999
  #  runAsGroup: 999
  #  fsGroup: 999

  nodeSelector: {}
  tolerations: []
  affinity:
    podAntiAffinity: soft
    nodeAffinity:
      type: hard
      matchExpressions:
        - key: nodeType
          operator: In
          values:
            - addon

argo-cd:
  nameOverride: argocd
  fullnameOverride: ""
  namespaceOverride: argocd
  createClusterRoles: true
  crds:
    install: true
    keep: true

  ## Globally shared configuration
  configs:
    cm:
      create: true
      annotations: {}
      application.instanceLabelKey: argocd.argoproj.io/instance
      server.rbac.log.enforce.enable: false
      exec.enabled: false
      admin.enabled: true
      timeout.reconciliation: 180s
      timeout.hard.reconciliation: 0s
      statusbadge.enabled: false
    params:
      create: true
      annotations: {}
      controller.status.processors: 20
      controller.operation.processors: 10
      controller.self.heal.timeout.seconds: 5
      controller.repo.server.timeout.seconds: 60
      applicationsetcontroller.policy: sync
      applicationsetcontroller.enable.progressive.syncs: false
    rbac:
      create: true
      annotations: {}
      policy.default: ""
      policy.csv: ""
      scopes: "[groups]"
      policy.matchMode: "glob"

  ## Application controller
  controller:
    name: application-controller
    replicas: 1
    heartbeatTime: 10
    revisionHistoryLimit: 5

  dex:
    enabled: true
    name: dex-server
    extraArgs: []
    image:
      repository: ghcr.io/dexidp/dex
      tag: v2.38.0
      imagePullPolicy: ""
    imagePullSecrets: []
    env: []
    envFrom: []
    # - configMapRef:
    #     name: config-map-name
    # - secretRef:
    #     name: secret-name

    volumeMounts: []
    volumes: []
    emptyDir:
      sizeLimit: ""

    deploymentAnnotations: {}
    podAnnotations: {}
    podLabels: {}
    resources: {}
    #  limits:
    #    cpu: 50m
    #    memory: 64Mi
    #  requests:
    #    cpu: 10m
    #    memory: 32Mi

    containerPorts:
      http: 5556
      grpc: 5557
      metrics: 5558

    dnsConfig: {}
    dnsPolicy: "ClusterFirst"

    terminationGracePeriodSeconds: 30

    serviceAccount:
      create: true
      name: argocd-dex-server

    servicePortHttp: 5556
    servicePortHttpName: http
    servicePortGrpc: 5557
    servicePortGrpcName: grpc
    servicePortMetrics: 5558

    logFormat: ""
    logLevel: ""
  #
  #  admin:
  #    existingSecret: argocd-initial-admin-secret

  redisSecretInit:
    podAnnotations:
      sidecar.istio.io/inject: "false"

  redis:
    enabled: true
    name: redis
    podAnnotations:
      sidecar.istio.io/inject: "false"

    image:
      repository: public.ecr.aws/docker/library/redis
      tag: 7.2.4-alpine
      imagePullPolicy: ""
    servicePort: 6379
    terminationGracePeriodSeconds: 30
    automountServiceAccountToken: true

  server:
    name: server
    replicas: 1
    image:
      repository: "" # defaults to global.image.repository
      tag: "" # defaults to global.image.tag
      imagePullPolicy: "" # IfNotPresent

    imagePullSecrets: []
    extraArgs:
      - --insecure
    env: []
    envFrom: []
    volumeMounts: []
    volumes: []

    emptyDir:
      sizeLimit: ""

    deploymentAnnotations: {}

    podAnnotations: {}

    podLabels: {}

    resources: {}

    containerPorts:
      server: 8080
      metrics: 8083

    service:
      annotations: {}
      labels: {}
      type: ClusterIP
      nodePortHttp: 30080
      nodePortHttps: 30443
      servicePortHttp: 80
      servicePortHttps: 443
      servicePortHttpName: http
      servicePortHttpsName: https
      servicePortHttpsAppProtocol: ""

    serviceAccount:
      create: true
      name: argocd-server

  repoServer:
    name: repo-server

    replicas: 1

    image:
      repository: ""
      tag: ""
      imagePullPolicy: ""

    imagePullSecrets: []

    extraArgs: []

    env: []

    envFrom: []
    # - configMapRef:
    #     name: config-map-name
    # - secretRef:
    #     name: secret-name

    volumeMounts: []

    volumes: []

    existingVolumes: {}

    useEphemeralHelmWorkingDir: true

    deploymentAnnotations: {}

    podAnnotations: {}

    podLabels: {}

    resources: {}

    containerPorts:
      server: 8081
      metrics: 8084

    hostNetwork: false

    dnsConfig: {}
    dnsPolicy: "ClusterFirst"

    service:
      annotations: {}
      labels: {}
      port: 8081
      portName: tcp-repo-server

    automountServiceAccountToken: true

    serviceAccount:
      create: true
      name: "" # "argocd-repo-server"
      annotations: {}
      labels: {}
      automountServiceAccountToken: true

  applicationSet:
    name: applicationset-controller

    replicas: 1

    image:
      repository: ""
      tag: ""
      imagePullPolicy: ""

    imagePullSecrets: []

    extraArgs: []

    extraEnv:
      []
    # - name: "MY_VAR"
    #   value: "value"

    extraEnvFrom:
      []
      # - configMapRef:
      #     name: config-map-name
    # - secretRef:
    #     name: secret-name

    extraVolumeMounts: []

    extraVolumes: []

    emptyDir:
      sizeLimit: ""

    deploymentAnnotations: {}

    podAnnotations: {}

    podLabels: {}

    resources:
      {}
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
    #   cpu: 100m
    #   memory: 128Mi

    containerPorts:
      metrics: 8080
      probe: 8081
      webhook: 7000

    dnsConfig: {}
    dnsPolicy: "ClusterFirst"

  notifications:
    enabled: true

    name: notifications-controller

    argocdUrl: ""

    logFormat: ""
    logLevel: ""

    extraArgs: []

    extraEnv: []

    extraEnvFrom:
      []
      # - configMapRef:
      #     name: config-map-name
    # - secretRef:
    #     name: secret-name

    secret:
      create: true
      name: "argocd-notifications-secret"

    resources: {}

    containerPorts:
      metrics: 9001

    automountServiceAccountToken: true

    serviceAccount:
      create: true
      name: argocd-notifications-controller
      automountServiceAccountToken: true

    cm:
      create: true

    subscriptions: []

    templates: {}

    triggers: {}
argo-rollouts:
  # -- Install and upgrade CRDs
  installCRDs: true
  # -- Keep CRD's on helm uninstall
  keepCRDs: true

  # -- `false` runs controller in namespaced mode (does not require cluster RBAC)
  clusterInstall: true

  # -- flag to enable creation of cluster aggregate roles (requires cluster RBAC)
  createClusterAggregateRoles: true

  # -- String to partially override "argo-rollouts.fullname" template
  nameOverride:

  # -- String to fully override "argo-rollouts.fullname" template
  fullnameOverride:

  ## Override APIVersions
  ## If you want to template helm charts but cannot access k8s API server
  ## you can set api versions here
  apiVersionOverrides:
    # -- String to override apiVersion of ingresses rendered by this helm chart
    ingress: "" # networking.k8s.io/v1beta1

  # -- Override the Kubernetes version, which is used to evaluate certain manifests
  kubeVersionOverride: ""

  # -- Additional manifests to deploy within the chart. A list of objects.
  ## Can be used to add secrets for Analysis with 3rd-party monitoring solutions.
  extraObjects:
    []
    # - apiVersion: v1
    #   kind: Secret
    #   metadata:
    #     name: datadog
    #   type: Opaque
  #   data:
  #     address: https://api.datadoghq.com
  #     api-key: <datadog-api-key>
  #     app-key: <datadog-app-key>

  global:
    # -- Annotations for all deployed Deployments
    deploymentAnnotations: {}
    # -- Labels for all deployed Deployments
    deploymentLabels: {}
    # -- Number of old deployment ReplicaSets to retain. The rest will be garbage collected.
    revisionHistoryLimit: 10

  controller:
    # -- Value of label `app.kubernetes.io/component`
    component: rollouts-controller
    # -- Annotations to be added to the controller deployment
    deploymentAnnotations: {}
    # -- Labels to be added to the controller deployment
    deploymentLabels: {}
    # -- Annotations to be added to application controller pods
    podAnnotations: {}
    # -- Labels to be added to the application controller pods
    podLabels: {}
    # -- [Node selector]
    nodeSelector: {}
    # -- [Tolerations] for use with node taints
    tolerations: []
    # -- Assign custom [affinity] rules to the deployment
    affinity:
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
            - matchExpressions:
                - key: nodeType
                  operator: In
                  values:
                    - addon
    logging:
      # -- Set the logging level (one of: `debug`, `info`, `warn`, `error`)
      level: info
      # -- Set the klog logging level
      kloglevel: "0"
      # -- Set the logging format (one of: `text`, `json`)
      format: "text"

    # -- The number of controller pods to run
    replicas: 2
    image:
      # -- Registry to use
      registry: quay.io
      # -- Repository to use
      repository: argoproj/argo-rollouts
      # -- Overrides the image tag (default is the chart appVersion)
      tag: ""
      # -- Image pull policy
      pullPolicy: IfNotPresent

    # -- Additional command line arguments to pass to rollouts-controller.  A list of flags.
    extraArgs: []

    # -- Additional environment variables for rollouts-controller. A list of name/value maps.
    extraEnv: []
    # - name: AWS_REGION
    #   value: us-east-1

    # -- Resource limits and requests for the controller pods.
    resources: {}

    # -- flag to enable creation of cluster controller role (requires cluster RBAC)
    createClusterRole: true

    # Controller container ports
    containerPorts:
      # -- Metrics container port
      metrics: 8090
      # -- Healthz container port
      healthz: 8080

    # -- Additional volumes to add to the controller pod
    volumes: []
    # - configMap:
    #     name: my-certs-cm
    #   name: my-certs

    # -- Additional volumeMounts to add to the controller container
    volumeMounts: []
    # - mountPath: /etc/ssl/certs
    #   name: my-certs

  serviceAccount:
    # -- Specifies whether a service account should be created
    create: true
    # -- Annotations to add to the service account
    annotations: {}
    # -- The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # -- Annotations for the all deployed pods
  podAnnotations: {}

  # -- Labels to be added to the Rollout pods
  podLabels: {}

  # -- Secrets with credentials to pull images from a private registry. Registry secret names as an array.
  imagePullSecrets: []
  # - name: argo-pull-secret

  providerRBAC:
    # -- Toggles addition of provider-specific RBAC rules to the controller Role and ClusterRole
    enabled: true
    # providerRBAC.enabled must be true in order to toggle the individual providers
    providers:
      # -- Adds RBAC rules for the Istio provider
      istio: true
      # -- Adds RBAC rules for the SMI provider
      smi: true
      # -- Adds RBAC rules for the Ambassador provider
      ambassador: true
      # -- Adds RBAC rules for the AWS Load Balancer Controller provider
      awsLoadBalancerController: true
      # -- Adds RBAC rules for the AWS App Mesh provider
      awsAppMesh: true
      # -- Adds RBAC rules for the Traefik provider
      traefik: true
      # -- Adds RBAC rules for the Apisix provider
      apisix: true
      # -- Adds RBAC rules for the Contour provider, see `https://github.com/argoproj-labs/rollouts-plugin-trafficrouter-contour/blob/main/README.md`
      contour: true
      # -- Adds RBAC rules for the Gloo Platform provider, see `https://github.com/argoproj-labs/rollouts-plugin-trafficrouter-glooplatform/blob/main/README.md`
      glooPlatform: true
      # -- Adds RBAC rules for the Gateway API provider
      gatewayAPI: true
    # -- Additional RBAC rules for others providers
    additionalRules: []

  dashboard:
    # -- Deploy dashboard server
    enabled: true
    # -- Set cluster role to readonly
    readonly: false
    # -- Value of label `app.kubernetes.io/component`
    component: rollouts-dashboard
    # -- Annotations to be added to the dashboard deployment
    deploymentAnnotations: {}
    # -- Labels to be added to the dashboard deployment
    deploymentLabels: {}
    # -- Annotations to be added to application dashboard pods
    podAnnotations: {}
    # -- Labels to be added to the application dashboard pods
    podLabels: {}
    # -- [Node selector]
    nodeSelector: {}
    # -- [Tolerations] for use with node taints
    tolerations: []
    # -- Assign custom [affinity] rules to the deployment
    affinity:
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
            - matchExpressions:
                - key: nodeType
                  operator: In
                  values:
                    - addon
    logging:
      # -- Set the logging level (one of: `debug`, `info`, `warn`, `error`)
      level: info
      # -- Set the klog logging level
      kloglevel: "0"

    # -- flag to enable creation of dashbord cluster role (requires cluster RBAC)
    createClusterRole: true

    # -- The number of dashboard pods to run
    replicas: 1
    image:
      # -- Registry to use
      registry: quay.io
      # --  Repository to use
      repository: argoproj/kubectl-argo-rollouts
      # -- Overrides the image tag (default is the chart appVersion)
      tag: ""
      # -- Image pull policy
      pullPolicy: IfNotPresent
    # -- Additional command line arguments to pass to rollouts-dashboard. A list of flags.
    extraArgs: []
    # -- Additional environment variables for rollouts-dashboard. A list of name/value maps.
    extraEnv: []
    # - name: FOO
    #   value: bar
    # -- Resource limits and requests for the dashboard pods.
    resources: {}
    # -- Security Context to set on pod level
    podSecurityContext:
      runAsNonRoot: true
    # -- Security Context to set on container level
    containerSecurityContext: {}
    service:
      # -- Sets the type of the Service
      type: ClusterIP
      # -- The class of the load balancer implementation
      loadBalancerClass: ""
      # -- LoadBalancer will get created with the IP specified in this field
      loadBalancerIP: ""
      # -- Source IP ranges to allow access to service from
      loadBalancerSourceRanges: []
      # -- Dashboard service external IPs
      externalIPs: []
      # -- Service annotations
      annotations: {}
      # -- Service labels
      labels: {}
      # -- Service port name
      portName: dashboard
      # -- Service port
      port: 80
      # -- Service target port
      targetPort: 3100
      # -- (int) Service nodePort
      nodePort:
    serviceAccount:
      # -- Specifies whether a dashboard service account should be created
      create: true
      # -- Annotations to add to the dashboard service account
      annotations: {}
      # -- The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

    # -- Additional volumes to add to the dashboard pod
    volumes: []

    # -- Additional volumeMounts to add to the dashboard container
    volumeMounts: []